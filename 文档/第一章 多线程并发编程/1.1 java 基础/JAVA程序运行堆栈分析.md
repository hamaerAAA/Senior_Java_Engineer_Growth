## JVM内存模型

​	JVM通过加载class文件的数据来执行程序。JVM在运行时会划分不同的区域来存放数据，如下图所示：

![](..\..\..\图片\1299353-20190526111201308-1628029487.png)

**线程共享部分**：所有线程都能访问这块内存的数据，随虚拟机或GC的创建和销毁。主要包括方法区和堆内存

**线程独享部分**：每个线程都有它独特的空间，随线程的创建和销毁。主要包括虚拟机栈、本地方法栈、程序						   计数器

**方法区**： 是JVM用来存储加载的类信息、常量、静态变量、编译后的代码数据。在虚拟机规范中，这是一个				逻辑区，不同虚拟机有不同的实现方式

**堆内存**： 在JVM启动时创建的，用于存放类的对象，new出来的对象都放在这里，可以细分为 老年代、新生代 垃圾回收期主要就是管理堆内存

**虚拟机栈**： 虚拟机栈是每一个线程私有的空间。线程栈由多个栈帧组成。栈帧的内容包含： 局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。栈内存默认最大为1M，超过会抛出StackOverFlowErorr

**本地方法栈**： 本地方法栈是为JVM执行native本地方法而准备的，不同的虚拟机厂商有不同的实现

**程序计数器：** 记录当前线程执行字节码的位置，存储的是字节码指令地址，如果执行native方法，则计数器为空。CPU统同一时间，只会执行一个线程中的一条指令。JVM多线程会轮流切换并分配CPU执行时间，因此在发生线程切换时，需要通过程序计数器来恢复正常的执行位置



#### 1.1  方法区学习

```
参考 https://blog.csdn.net/u014683488/article/details/108253159

·类信息
	类的全限定名  例com.lj.test.Test
	超类的全限定名  对于interface或是java.lang.Object，都没有父类
	直接超接口的全限定名 
	类标志  (该类是类类型还是接口类型)
	类的访问描述符 (public private default protected abstract final static)
	
·类的常量池
	存放该类所用到的常量的有序集合，包括直接常量(如字符串、整数、浮点数的常量)和其他类型、字段、方法的符号引用。

·字段信息
    字段修饰符  public protected private default
    字段的类型
    字段名称
    
·方法信息
    方法修饰符 public  private protected synchronized abstract final static native
    方法返回类型
    方法名
    方法参数个数、类型、顺序
    方法字节码
    操作数栈和该方法在栈帧中的局部变量区大小
    异常表
    
·类变量（静态变量）
	指的是该类所有对象共享的变量，即使没有任何实例对象，也可以访问的类变量。因为它们与类进行绑定

·指向类加载器的引用
	每一个被JVM加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到

·指向Class实例的应用
	类加载过程中，虚拟机会创建该类行的Class实例，方法区中必须保存对该对象的引用。通过Class.forNmae(Stirng className) 来查找获得该实例的引用，然后创建该类对象
	
·方法表
	为了提高访问效率，JVM可能会对每个装载的非抽象类，都创建一个数组，数组的每个元素的实力可能调用的方法的直接引用，包括父类中继承过来的方法。这个表在抽象类或者接口中是没有的

·运行时常量池
	Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面常量和符号引用，这部分内容被类加载后进入方法区的运行时常量池中存放。
```



##### 1.1.1 方法区与堆的异同

​	I. **方法区主要存放的是Class，而堆中主要存放的是实例化的对象**

```
 Person       person   =    new Person()
 存放在方法区   java栈				java堆
```

​	II. **方法区和堆都是线程共享的JVM区域**

​	III. **方法区在JVM启动的时候被创建，并且它的实际的实际物理内存中和java堆区都可以是不连续的**

​	IIII. **方法区和堆可以设定固定大小和扩展**

##### 1.1.2 方法区常见问题

​	I. **方法区的大小决定系统可以保存多少个类**

```
	java.lang.OutofMemoryError：PermGen space
	java.lang.OutOfMemoryError: Metaspace  ★
		翻译： PermGen 永久代(jdk 1.6) Metaspace 元空间(jdk 1.8)
	原因：
		加载大量的第三方jar包
		大量动态的生成反射类
		tomcat部署的工程过多
	
	解决方法：
		参考 https://blog.csdn.net/renfufei/article/details/77994177
		核心思想就是 设置更大的方法区空间
				-XX:MaxMetaspaceSize=512m
```

​	II. **JDK1.7 和 JDK1.8 方法区的区别**

```
	方法区在1.7中是永久代PermGen  在 1.8中是元空间Meta space
    元空间不在虚拟机设置的内存中，使用的是本地内存
```

